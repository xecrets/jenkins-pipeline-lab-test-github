// Global variables needed to communicate between script blocks
def slackUserEmails  = []
def slackUserIdsNotification = ""

pipeline {
    triggers { pollSCM('* * * * *') }
    options { timestamps() }
    agent {
        node {
            label 'master'
            customWorkspace "/workspace/jenkins-pipeline-lab-test-github/master"
        }
    }
    stages {
        stage('Checkout') {
			steps {
				dir('test') {
					// git branch: "master", url: 'https://github.com/xecrets/jenkins-pipeline-lab-test-github.git'
				}
			}
		}
		stage ('Do something') {
			steps {
				script {
					bat "exit 1"
				}
			}
		}
    }
	post {
		always {
			// Get changeSets manually to get authors since slackSend notifyCommitters: true et. al. throws a NullPointerException and/or does not work
			script {
				def changeLogSets = currentBuild.changeSets
				for (int i = 0; i < changeLogSets.size(); i++) {
					def entries = changeLogSets[i].items
					for (int j = 0; j < entries.length; j++) {
						def entry = entries[j]
						def emailAddress = entry.author.getProperty(hudson.tasks.Mailer.UserProperty.class)?.getAddress()?.toString()
						if (emailAddress?.trim()) {
							slackUserEmails.add(emailAddress)
						}
						echo "${entry.commitId} by '${entry.author}' with email '${emailAddress}' on ${new Date(entry.timestamp)}: ${entry.msg}"

						def files = new ArrayList(entry.affectedFiles)
						for (int k = 0; k < files.size(); k++) {
							def file = files[k]
							echo "  ${file.editType.name} ${file.path}"
						}
					}
				}
			}
			// This has to be in a separate script block because use of slackUserIdFromEmail() causes things to be serialized, and the changeLogLets in
			// the previous block can't be serialized, causing an exception.
			script {
				def slackUserIds = slackUserEmails.collect { slackUserIdFromEmail(it) }
				slackUserIdsNotification = slackUserIds.collect { "<@$it>" }.join(' ')
			}
		}
		success {
			script {
				slackSend color: "good", message: "${slackUserIdsNotification} Pipeline Testing indicates a SUCCESSFUL build.", notifyCommitters: false
			}
		}
		regression {
			script {
				if (currentBuild.result == 'UNSTABLE') {
					slackSend color: "warning", message: "${slackUserIdsNotification} Pipeline Testing indicates regression to an UNSTABLE build.", notifyCommitters: false
				}
				if (currentBuild.result == 'FAILURE') {
					slackSend color: "danger", message: "${slackUserIdsNotification} Pipeline Testing indicates regression to a FAILED build.", notifyCommitters: false
				}
			}
		}
		failure {
			script {
				if (currentBuild.result == 'UNSTABLE') {
					slackSend color: "warning", message: "${slackUserIdsNotification} Pipeline Testing indicates an UNSTABLE build.", notifyCommitters: false
				}
				if (currentBuild.result == 'FAILURE') {
					slackSend color: "danger", message: "${slackUserIdsNotification} Pipeline Testing indicates a FAILED build.", notifyCommitters: false
				}
			}
		}
	}
}