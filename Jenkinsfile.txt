// Global variables needed to communicate between script blocks
def slackUserEmails  = []
def slackUserIdsNotification = ""

pipeline {
    triggers { pollSCM('* * * * *') }
    options { timestamps() }
    agent {
        node {
            label 'master'
            customWorkspace "/workspace/jenkins-pipeline-lab-test-github/master"
        }
    }
    stages {
        stage('Checkout') {
			steps {
				dir('test') {
					// git branch: "master", url: 'https://github.com/xecrets/jenkins-pipeline-lab-test-github.git'
				}
			}
		}
		stage ('Do something') {
			steps {
				script {
					echo "Doing stuff..."
					bat "exit 1"
				}
			}
		}
    }
	post {
		always {
			// Get changeSets manually to get authors since slackSend notifyCommitters: true et. al. throws a NullPointerException and/or does not work
			script {
				def changeLogSets = currentBuild.changeSets
				for (int i = 0; i < changeLogSets.size(); i++) {
					def entries = changeLogSets[i].items
					for (int j = 0; j < entries.length; j++) {
						def entry = entries[j]
						def emailAddress = entry.author.getProperty(hudson.tasks.Mailer.UserProperty.class)?.getAddress()?.toString()
						if (emailAddress?.trim()) {
							slackUserEmails.add(emailAddress)
						}
						echo "${entry.commitId} by '${entry.author}' with email '${emailAddress}' on ${new Date(entry.timestamp)}: ${entry.msg}"

						def files = new ArrayList(entry.affectedFiles)
						for (int k = 0; k < files.size(); k++) {
							def file = files[k]
							echo "  ${file.editType.name} ${file.path}"
						}
					}
				}
			}
			    // wrap([$class: 'BuildUser']) { //
					// echo "2"
					//  def buildUser = BUILD_USER_EMAIL
					// echo "3"
					// echo "Build user is ${buildUser}"
				//}
			// This has to be in a separate script block because use of slackUserIdFromEmail() causes things to be serialized, and the changeLogLets in
			// the previous block can't be serialized, causing an exception.
			script {
				echo "1"
				// echo currentBuild.getBuildCauses('hudson.model.Cause$UserIdCause')[0]['userId']
				echo "4"
				def slackUserIds = slackUserEmails.collect { slackUserIdFromEmail(it) }
				slackUserIdsNotification = slackUserIds.collect { "<@$it>" }.join(' ')
			}
		}
		regression {
			script {
				if (currentBuild.result == 'UNSTABLE') {
					slackSend color: "warning", message: "${slackUserIdsNotification} Nedrans, någon eller några tester har gått snett! Bara sätta igång och laga.", notifyCommitters: false
				}
				if (currentBuild.result == 'FAILURE') {
					slackSend color: "danger", message: "${slackUserIdsNotification} Attans, det går inte att bygga! Skynda, skynda fixa!", notifyCommitters: false
				}
			}
		}
		failure {
			script {
				if (currentBuild.result == 'UNSTABLE') {
					slackSend color: "warning", message: "${slackUserIdsNotification} Ledsen, men några tester är fortfarande trasiga. Skam den som ger sig, på den igen!", notifyCommitters: false
				}
				if (currentBuild.result == 'FAILURE') {
					slackSend color: "danger", message: "${slackUserIdsNotification} Det går inte så bra nu, det gick inte att bygga nu heller. Försök igen!", notifyCommitters: false
				}
			}
		}
		fixed {
			script {
				slackSend color: "warning", message: "${slackUserIdsNotification} Bra där, nu lirar allt igen!", notifyCommitters: false
			}
		}
	}
}